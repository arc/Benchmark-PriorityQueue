#! /usr/bin/perl

use v5.10;
use strict;
use warnings;

use Benchmark qw<cmpthese>;
use Benchmark::PriorityQueue qw<all_backends all_tasks>;
use Getopt::Long qw<GetOptions :config gnu_getopt>;

my $USAGE = <<'EOF';
Usage: cmp_pq [OPTION]...

Options:

  -i ITERATIONS
    Number of iterations to run in each timing test; default 10; negative
    means number of seconds to iterate

  -n NUM
    Use NUM as the "rank" for each workload; multiple allowed; 1000 if
    none specified

  -m BACKEND
    Backend module to benchmark, like List::Priority; multiple allowed; all
    if none specified

  -b TASK
    Task to run; multiple allowed; all if none specified

EOF

GetOptions(\my %opt, qw<i=i n=i@ m=s@ b=s@ help|?>)
    or die $USAGE;

if ($opt{help}) {
    print $USAGE;
    exit 0;
}

$opt{i} //= 10;
$opt{n} ||= [1000];
$opt{m} ||= [all_backends()];
$opt{b} ||= [all_tasks()];

my %abbr;
{
    my %seen;
    for my $backend (@{ $opt{m} }) {
        (my $abbr = $backend)
            =~ s/ (?<= [A-Z] ) [A-Z]* (?: (?=::) | [_a-z0-9]+ ) //xmsg;
        $abbr =~ s/::/:/g;
        my $disambiguated = $abbr;
        for (my $n = 1; ; $disambiguated = sprintf '%s-%d', $abbr, ++$n) {
            if (!$seen{$disambiguated}++) {
                say "$disambiguated = $backend";
                $abbr{$backend} = $disambiguated;
                last;
            }
        }
    }
}

for my $task (@{ $opt{b} }) {
    my @shims =
        grep { $_->supports($task) }
        map  { "Benchmark::PriorityQueue::$_"->new(iterations => $opt{i}) }
        @{ $opt{m} };
    for my $rank (@{ $opt{n} }) {
        local $| = 1;
        say '';
        print "Running $task on ", scalar @shims, " backends, rank=$rank ";
        my %result;
        for my $shim (@shims) {
            print '.';
            my $abbr = $abbr{ $shim->backend };
            $result{$abbr} = $shim->time_workload($task, $rank);
        }
        say '';
        cmpthese(\%result);
    }
}
