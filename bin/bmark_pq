#!/usr/bin/perl

use strict;
use warnings;
use 5.10.0;
use IO::File;
use List::MoreUtils qw<uniq>;
use Benchmark qw<cmpthese>;
use Benchmark::PriorityQueue qw<run_workloads all_tasks all_backends>;
use Getopt::Long qw<GetOptions :config gnu_getopt>;

my $default_max_rank_exponent = 3;
GetOptions("b=s"      => \ my @backends,
	   "t=s"      => \ my @tasks,
	   "r=i"      => \ my @ranks,
	   "n=i"      => \(my $max_rank_exponent = $default_max_rank_exponent),
	   "T=i"      => \ my $timeout,
	   "o=s"      => \ my $out_file,
	   "v"        => \ my $verbose,
	   "help|?|h" => \ my $help)
	or usage(2);

if ($help) {
	usage(0);
}

usage(2) if @ARGV;

@ranks = map { 10**$_ } 1 .. $max_rank_exponent
	if !@ranks;

my $out_fh = \*STDOUT;
$out_fh = IO::File->new($out_file, 'w')
	or die "Can't open $out_file for writing: $!\n"
		if defined $out_file;

my %format_op = (
	csv => {
		gather	 => sub {},
		start	 => sub { STDERR->autoflush(1) },
		generate => sub {
			my @results = @_;

			print STDERR "\n" if $verbose;

			# XXX: probably better to use a real CSV-generating module
			local $\ = "\x0D\x0A";      # CSV uses CRLF
			print $out_fh join ',',
				qw<Task Backend Version Rank Iterations Seconds>;
			for my $result (@results) {
				print $out_fh join ',', map { $result->$_ }
					qw<task backend backend_version rank iterations seconds>;
			}
		},
		progress => sub {
			my ($task, $backend, $rank) = @_;
			return if !$verbose;
			state $prev_task    = '';
			state $prev_backend = '';
			print STDERR "\nRunning $task on $backend "
				if $task ne $prev_task || $backend ne $prev_backend;
			print STDERR '.';
			($prev_task, $prev_backend) = ($task, $backend);
		},
	},

	compare => {
		generate => sub {},
		start    => sub {
			# This restriction seems hard to remove.  Applying
			# timeouts on a per-benchmark basis means that ranks
			# are nested within (backends and tasks); but here
			# we want to nest backends within (ranks and tasks).
			# Rather than give run_workloads() the ability to
			# invert its loops, we just forbid the awkward case;
			# users can apply a shell loop if they want multiple
			# ranks.
			die "Only one rank accepted for 'compare' output format\n"
				if @ranks > 1;

			$out_fh->autoflush(1) if !defined $out_file;
			select $out_fh; # for cmpthese()
		},
		progress => sub {
			my ($task, $backend, $rank) = @_;
			state $prev_task    = '';
			state $prev_backend = '';
			print "\nRunning $task, rank=$rank "
				if $task ne $prev_task;
			print '.';
			($prev_task, $prev_backend) = ($task, $backend);
		},
		gather => sub {
			my ($task, @results) = @_;
			print "\n";
			cmpthese({ map { $_->backend => $_->results } @results })
			    if @results;
		},
	},
);

my ($format) = reverse sort keys %format_op; # temporarily

{
	$format_op{$format}{start}->();
	my @results = run_workloads(
		tasks    => @tasks    && \@tasks,
		backends => @backends && \@backends,
		ranks    => \@ranks,
		timeout  => $timeout,
		progress => $format_op{$format}{progress},
		gather   => $format_op{$format}{gather},
	);
	$format_op{$format}{generate}->(@results);
}

close $out_fh
	or die "Can't close output: $!\n";

sub usage {
	my ($status) = @_;
	select STDERR if $status != 0;
	say <<END;
Usage:
    $0  -n [exp] -T [timeout] -b [backend 1] -b [backend 2] -t [task 1] ...

Options:
    -b  Backend to benchmark, eg List::Priority. If no -m options are given, all
        priority queue backends are benchmarked.

    -t  Task to run. If no -b options are given, all tasks are run.

    -r RANK
        Rank values to run for each benchmark. If no -r options are given,
        we use 10, 100, 1000, ... up to the limit given by the -n option

    -n  Maximum rank exponent to use. For example, if -n 3 is used,
        data-structures of at most 1000 elements (= 10^3) are used for
        benchmarking.  Defaults to $default_max_rank_exponent.

    -T  Timeout in seconds. If this time is exceeded for a given
	task/backend pair, we give up and move on to the next one.

    -o FILE
        Write output to FILE; default: standard output

    -v  Emit progress messages to standard error

END
	print_tasks();
	say "";
	print_backends();
	say "";
	exit $status;
}

sub print_tasks {
	say "Available tasks:";
	print(map { "   $_\n" } all_tasks());
}

sub print_backends {
	say "Available backends to benchmark:";
	print(map { "   $_\n" } all_backends());
}
