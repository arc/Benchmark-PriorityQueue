#!/usr/bin/perl

use strict;
use warnings;
use 5.10.0;
use Benchmark::PriorityQueue qw'run_benchmark all_benchmarks all_tested_modules';
use Getopt::Long;
use DateTime::Duration;

my $default_n = 3;
my @modules; my @benchmarks; my $help; my $timeout;
my $n = $default_n;
GetOptions ("m=s" => \@modules,
	    "b=s" => \@benchmarks,
	    "n=i" => \$n,
	    "t=i" => \$timeout,
	    "help|?|h" => \$help)
	or usage(2);

if ($help) {
	usage(0);
}

usage(2) if @ARGV;

$timeout = DateTime::Duration->new(seconds => $timeout // 0);
@benchmarks = all_benchmarks() if !@benchmarks;

run_benchmark($_, $n, $timeout, @modules)
	for @benchmarks;

sub usage {
	my ($status) = @_;
	select STDERR if $status != 0;
	say <<END;
Usage:
    $0  -n [exp] -t [timeout] -m [module 1] -m [module 2] -b [benchmark 1] ...

Options: 
    -m  Module to benchmark, eg List::Priority. If no -m options are given, all
        priority queue modules are benchmarked.

    -b  Benchmark to run. If no -b options are given, all benchmarks are run.

    -n  Maximum exponent to use. For example, if -n 3 is used, data-structures
        of at most 1000 elements (= 10^3) are used for benchmarking.
	Defaults to $default_n.

    -t  Timeout in seconds. If this time is exceeded for a given
	benchmark/module pair, we give up and move on to the next one.
END
	print_benchmarks();
	say "";
	print_modules();
	say "";
	exit $status;
}

sub print_benchmarks {
	say "Available benchmarks:";
	print(map { "   $_\n" } all_benchmarks());
}

sub print_modules {
	say "Available modules to benchmark:";
	print(map { "   $_\n" } all_tested_modules());
}
