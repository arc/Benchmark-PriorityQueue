#!/usr/bin/perl

use strict;
use warnings;
use 5.10.0;
use Benchmark::PriorityQueue qw<run_workloads all_tasks all_backends>;
use Getopt::Long qw<GetOptions :config gnu_getopt>;

my $default_max_rank_exponent = 3;
GetOptions("b=s"      => \ my @backends,
	   "t=s"      => \ my @tasks,
	   "n=i"      => \(my $max_rank_exponent = $default_max_rank_exponent),
	   "T=i"      => \ my $timeout,
	   "help|?|h" => \ my $help)
	or usage(2);

if ($help) {
	usage(0);
}

usage(2) if @ARGV;

{
	my @results = run_workloads(
		tasks    => @tasks    && \@tasks,
		backends => @backends && \@backends,
		ranks    => [map { 10**$_ } 1 .. $max_rank_exponent],
		timeout  => $timeout,
	);

	# XXX: probably better to use a real CSV-generating module
	local $\ = "\x0D\x0A";      # CSV uses CRLF
	print join ',', qw<Task Backend Version Rank Iterations Seconds>;
	for my $result (@results) {
		print join ',', map { $result->$_ }
			qw<task backend backend_version rank iterations seconds>;
	}
}

sub usage {
	my ($status) = @_;
	select STDERR if $status != 0;
	say <<END;
Usage:
    $0  -n [exp] -T [timeout] -b [backend 1] -b [backend 2] -t [task 1] ...

Options:
    -b  Backend to benchmark, eg List::Priority. If no -m options are given, all
        priority queue backends are benchmarked.

    -t  Task to run. If no -b options are given, all tasks are run.

    -n  Maximum rank exponent to use. For example, if -n 3 is used,
        data-structures of at most 1000 elements (= 10^3) are used for
        benchmarking.  Defaults to $default_max_rank_exponent.

    -T  Timeout in seconds. If this time is exceeded for a given
	task/backend pair, we give up and move on to the next one.
END
	print_tasks();
	say "";
	print_backends();
	say "";
	exit $status;
}

sub print_tasks {
	say "Available tasks:";
	print(map { "   $_\n" } all_tasks());
}

sub print_backends {
	say "Available backends to benchmark:";
	print(map { "   $_\n" } all_backends());
}
