#!/usr/bin/perl

use strict;
use warnings;
use 5.10.0;
use IO::File;
use Benchmark::PriorityQueue qw<run_workloads all_tasks all_backends>;
use Getopt::Long qw<GetOptions :config gnu_getopt>;

my $default_max_rank_exponent = 3;
GetOptions("b=s"      => \ my @backends,
	   "t=s"      => \ my @tasks,
	   "r=i"      => \ my @ranks,
	   "n=i"      => \(my $max_rank_exponent = $default_max_rank_exponent),
	   "T=i"      => \ my $timeout,
	   "o=s"      => \ my $out_file,
	   "v"        => \ my $verbose,
	   "help|?|h" => \ my $help)
	or usage(2);

if ($help) {
	usage(0);
}

usage(2) if @ARGV;

@ranks = map { 10**$_ } 1 .. $max_rank_exponent
	if !@ranks;

my $out_fh = \*STDOUT;
$out_fh = IO::File->new($out_file, 'w')
	or die "Can't open $out_file for writing: $!\n"
		if defined $out_file;

STDERR->autoflush(1);

{
	my @results = run_workloads(
		tasks    => @tasks    && \@tasks,
		backends => @backends && \@backends,
		ranks    => \@ranks,
		timeout  => $timeout,
		progress => $verbose && sub {
			my ($task, $backend, $rank) = @_;
			state $prev_task    = '';
			state $prev_backend = '';
			print STDERR "\nRunning $task on $backend "
				if $task ne $prev_task || $backend ne $prev_backend;
			print STDERR '.';
			($prev_task, $prev_backend) = ($task, $backend);
		},
	);
	print STDERR "\n" if $verbose;

	# XXX: probably better to use a real CSV-generating module
	local $\ = "\x0D\x0A";      # CSV uses CRLF
	print $out_fh join ',', qw<Task Backend Version Rank Iterations Seconds>;
	for my $result (@results) {
		print $out_fh join ',', map { $result->$_ }
			qw<task backend backend_version rank iterations seconds>;
	}
}

close $out_fh
	or die "Can't close output: $!\n";

sub usage {
	my ($status) = @_;
	select STDERR if $status != 0;
	say <<END;
Usage:
    $0  -n [exp] -T [timeout] -b [backend 1] -b [backend 2] -t [task 1] ...

Options:
    -b  Backend to benchmark, eg List::Priority. If no -m options are given, all
        priority queue backends are benchmarked.

    -t  Task to run. If no -b options are given, all tasks are run.

    -r RANK
        Rank values to run for each benchmark. If no -r options are given,
        we use 10, 100, 1000, ... up to the limit given by the -n option

    -n  Maximum rank exponent to use. For example, if -n 3 is used,
        data-structures of at most 1000 elements (= 10^3) are used for
        benchmarking.  Defaults to $default_max_rank_exponent.

    -T  Timeout in seconds. If this time is exceeded for a given
	task/backend pair, we give up and move on to the next one.

    -o FILE
        Write output to FILE; default: standard output

    -v  Emit progress messages to standard error

END
	print_tasks();
	say "";
	print_backends();
	say "";
	exit $status;
}

sub print_tasks {
	say "Available tasks:";
	print(map { "   $_\n" } all_tasks());
}

sub print_backends {
	say "Available backends to benchmark:";
	print(map { "   $_\n" } all_backends());
}
